# Create a session and generate a token for session members
post '/start' => sub ($c) {

    # Init
    my $session = $c->model->add_session(name => $c->param('name'));
    my $chair   = $session->add_person(
        name => $c->param('pname') // ('Anonymous' . int(rand 10_000)),
        star => $c->param('sex') ne 'male'
    );

    # Store and work with it
    $c->session(
        token       => $session->token,
        person_id   => $chair->id,
        role        => 'chair',
    )->redirect_to('host');
};

# Join a session
post '/join' => sub ($c) {

    # Lookup session
    my $session = $c->model->sessions->{$c->param('token')};
    return $c->reply->not_found unless defined $session;

    # Inject data
    my $person = $session->add_person(
        name => $c->param('name') // ('Anonymous' . int(rand 10_000)),
        star => $c->param('sex') ne 'male',
    );

    # Store and work with it
    $c->session(
        token       => $session->token,
        person_id   => $person->id,
        role        => 'user'
    )->redirect_to('attend');
};

# A session has been joined, retrieve its data
under sub ($c) {

    # Session found?
    my $session = $c->model->sessions->{$c->session('token')};
    return $c->reply->not_found unless defined $session;

    # Si!
    $c->stash(
        session     => $session,
        person_id   => $c->session('person_id'),
        role        => $c->session('role'),
    );
    return 1;
};

# Host a session
get '/host' => sub ($c) {
    return $c->reply->not_found unless $c->session('role') eq 'chair';
    $c->render(template => 'redeliste', role => 'chair');
};

# Attend a session
get '/attend' => sub ($c) {
    $c->render(template => 'redeliste', role => 'user');
};

# Read state data dump as JSON/text
get '/data' => [format => 'json'] => sub ($c) {
    $c->render(json => $c->state_dump);
};
get '/data' => [format => 'txt'] => sub ($c) {
	$c->render(text => $c->dumper($c->state_dump));
};

# Push synchronization
websocket '/sync' => sub ($c) {

    # Keep connection alive for at least one day
    $c->inactivity_timeout(app->config('timeout'));

    # Lookup corresponding data
    my $session = $c->stash('session');
    my $person  = $session->persons->[$c->stash('person_id')];
    return $c->reply->not_found unless $person;

    # Store connection
    $person->tx($c->tx)->active(1);

    # React on a message
    $c->on(message => sub ($self, $message) {

        # Close the whole session
        if ($message eq 'CLOSESESSION') {
            delete $c->model->sessions->{$session->{token}};
            $c->broadclose;
            return;
        }

        # Dispatch messages
        for ($message) {
            /^RQSP$/        && $session->add_request($person);
            /^NEXT$/        && $session->call_next_speaker;
            /^CLOSELIST$/   && $session->list_open('');
            /^OPENLIST$/    && $session->list_open(1);
            /^NEXTITEM$/    && $session->next_item;
            $c->broadcast;
        }
    });

    # React on a client leaving
    $c->on(finish => sub {

        # Chair: close everything
        if ($c->stash('role') eq 'chair') {
            delete $c->model->sessions->{$session->{token}};
            $c->broadclose;
        }

        # User: just let them know
        else {
            $person->tx(undef)->active(0);
            $c->broadcast;
        }
    });

    # Send updated session data to all clients
    $c->broadcast;
};

# Reset local storage
get '/reset' => sub ($c) {
    $c->session({})->render(text => 'OK');
};
