# Read state data dump as JSON/text
get '/data' => [format => 'json'] => sub ($c) {
    $c->render(json => $c->state_dump);
};
get '/data' => [format => 'txt'] => sub ($c) {
	$c->render(text => $c->dumper($c->state_dump));
};

# Push synchronization
websocket '/sync' => sub ($c) {

    # Keep connection alive for at least one day
    $c->inactivity_timeout(app->config('timeout'));

    # Lookup corresponding data
    my $session = $c->stash('session');
    my $person  = $session->persons->[$c->stash('person_id')];
    return $c->reply->not_found unless $person;

    # Store connection
    $person->tx($c->tx)->active(1);

    # React on a message
    $c->on(message => sub ($self, $message) {

        # Close the whole session
        if ($message eq 'CLOSESESSION') {
            delete $c->model->sessions->{$session->{token}};
            $c->broadclose;
            return;
        }

        # Dispatch messages
        for ($message) {
            /^RQSP$/        && $session->add_request($person);
            /^NEXT$/        && $session->call_next_speaker;
            /^CLOSELIST$/   && $session->list_open('');
            /^OPENLIST$/    && $session->list_open(1);
            /^NEXTITEM$/    && $session->next_item;
            $c->broadcast;
        }
    });

    # React on a client leaving
    $c->on(finish => sub {

        # Chair: close everything
        if ($c->stash('role') eq 'chair') {
            delete $c->model->sessions->{$session->{token}};
            $c->broadclose;
        }

        # User: just let them know
        else {
            $person->tx(undef)->active(0);
            $c->broadcast;
        }
    });

    # Send updated session data to all clients
    $c->broadcast;
};

# Reset local storage
get '/reset' => sub ($c) {
    $c->session({})->render(text => 'OK');
};
